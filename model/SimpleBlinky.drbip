model SimpleBlinky

import from "SimpleBlinky.cpp" {

    condition NodeCore(CORE)
    condition NodeSurface(SURFACES)
    //condition NodeSurfaceLeft(SURFACES)
    //condition NodeSurfaceRight(SURFACES)

    structure SimpleBlinkyMap {
        Node addCore()
        Node addSurfaces()
        void eraseCore()
        void eraseSurfaces()
    }

    structure BBMap {
        Node initialize()
        void insertLeft(Node, Node)
        bool isNeighbour(Node, Node, int)
        bool hasNeighbour(Node, int)
    }
}

motif Block<SimpleBlinkyMap, DefaultAddressing> {
    rule configuration CreateBlinky()
    when(true){
        c = new CORE(C.size())
        nodeCore = S.addCore()
        (CORE FROM C).insert(c)
        @.bind(c, nodeCore)

        s = new SURFACES()
        nodeSurfaces = S.addSurfaces()
        (SURFACES FROM C).insert(s)
        @.bind(s, nodeSurfaces)

        new ConnectCoreAndSurface(c, s)
    }
}

motif Shape<BBMap> {
    rule configuration Init()
    when(true) {
        b1 = new Block()
        b1.CreateBlinky()
    }
}

global rule AddBlock(Shape s, Block b1)
when(true)
{
    b2 = new Block()
    b2.CreateBlinky()
    new Connection(b1, b2)
}

initializer {
    s = new Shape()
    s.Init()

    AddBlock(s, b)
}