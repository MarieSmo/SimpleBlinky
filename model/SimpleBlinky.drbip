model SimpleBlinky

import from "SimpleBlinky.cpp" {

    condition NodeCore(CORE)
    condition NodeSurfaceLeft(SURFACE)
    condition NodeSurfaceRight(SURFACE)

    structure SimpleBlinkyMap {
        Node create()
        void setCore(Node)
        void setSurfaceLeft(Node)
        void setSurfaceRight(Node)
        const Node getCore()
        const Node getLeft()
        const Node getRight()
        const bool isCore(Node)
        const bool isLeft(Node)
        const bool isRight(Node)
        const int getCoreId(CORE)
    }

    structure BBMap {
        void insertCore(Node)
        void connectLeft(Node, Node)
        void connectRight(Node, Node)
        const bool isNeighbour(Node, Node, int)
        const bool hasNeighbour(Node, CORE, int)
        const bool isAlrdeadyConnected(Node, Node)
        void printConnection(CORE, int, CORE, int)
        const bool isSurfaceFreeToUse(SURFACE)
        const bool isAssemble(CORE)
    }

    addressing BBAddressing {
    }
}

motif Block<SimpleBlinkyMap, DefaultAddressing> {
    rule interaction AssembledIR(CORE core, SURFACE left, SURFACE right)
    when(S.isCore(@core), S.isLeft(@left), S.isRight(@right)){
        new ConnectCoreAndSurface(core, left, right)
    }

    rule configuration BlockAdd() when(C.size() < 1)
    {
        core = new CORE(C.size()-1)

        // --- Core used for the BlinkyBlock element
        nodeCoreBlock = S.create()
        S.setCore(nodeCoreBlock)
        @.bind(core, nodeCoreBlock)
        (CORE FROM C).insert(core)

        // Surface left
        sl = new SURFACE(4, S.getCoreId(core))
        NodeSL = S.create()
        @.bind(sl, NodeSL)
        S.setSurfaceLeft(NodeSL)
        (SURFACE FROM C).insert(sl)

        // Surface right
        sr = new SURFACE(8, S.getCoreId(core))
        NodeSR = S.create()
        @.bind(sr, NodeSR)
        S.setSurfaceRight(NodeSR)
        (SURFACE FROM C).insert(sr)
    }
}

motif Shape<BBMap, DefaultAddressing> {
    rule interaction ConnectionIR(SURFACE s1, SURFACE s2)
    when(
        true,
        s1 != s2
    ) {
        new Connection(s1, s2)
    }
}

global rule ConnectBlockOnXAxisIMR(Shape shape, CORE cLeft, CORE cRight, Block bLeft, Block bRight, SURFACE sLeft, SURFACE sRight)
when(true,
    cLeft IN shape.C && !shape.S.hasNeighbour(shape.@cLeft, cLeft, 1) /*&& shape.S.isAssemble(cLeft)*/,
    cRight IN shape.C && cLeft != cRight && !shape.S.hasNeighbour(shape.@cRight, cRight, 2) /*&& shape.S.isAssemble(cRight)*/ && !shape.S.isAlrdeadyConnected(shape.@cLeft, shape.@cRight),
    cLeft in bLeft.C,
    cRight in bRight.C && bLeft != bRight,
    sLeft in bLeft.C && bLeft.S.isLeft(bLeft.@sLeft) && shape.S.isSurfaceFreeToUse(sLeft),
    sRight in bRight.C && bRight.S.isRight(bRight.@sRight) && sLeft != sRight && shape.S.isSurfaceFreeToUse(sRight)
)
{
    shape.ConnectionIR(sLeft, sRight)
    shape.S.printConnection(cLeft, 4, cRight, 8)
    // new Connection(sLeft, sRight)
    shape.S.connectLeft(shape.@cLeft, shape.@cRight)
}

initializer {
    shape = new Shape()

    for(i : seq(1, 4)) {
        block = new Block()
        // Core
        block.BlockAdd()

        // --- Core used into the shape to connect different block between each other
        /*nodeCoreShape = shape.S.create()
        shape.S.insertCore(nodeCoreShape)
        shape.@.bind(core, nodeCoreShape)
        (CORE FROM shape.C).insert(core.getCore())*/
    }
}