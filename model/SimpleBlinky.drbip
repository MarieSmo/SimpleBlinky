model SimpleBlinky

import from "SimpleBlinky.cpp" {

    condition NodeCore(CORE)
    condition NodeSurfaceLeft(SURFACE)
    condition NodeSurfaceRight(SURFACE)

    structure SimpleBlinkyMap {
        Node create()
        void setCore(Node)
        void setSurfaceLeft(Node)
        void setSurfaceRight(Node)
        const Node getCore()
        const Node getLeft()
        const Node getRight()
        const bool isCore(Node)
        const bool isLeft(Node)
        const bool isRight(Node)
    }

    structure BBMap {
        void insertCore(Node)
        void insertLeft(Node, Node)
        void insertRight(Node, Node)
        const bool isNeighbour(Node, Node, int)
        const bool hasNeighbour(Node, int)
    }

    addressing BBAddressing {
    }
}

motif Block<SimpleBlinkyMap, DefaultAddressing> {
    rule interaction AssembledLeft(CORE core, SURFACE left, SURFACE right)
    when(S.isCore(@core), S.isLeft(@left), S.isRight(@right)){
        new ConnectCoreAndSurface(core, left, right)
    }
}

motif Shape<BBMap, BBAddressing> {
    rule interaction connectSurface(SURFACE s1, SURFACE s2)
    when(true) {
        new Connection(s1, s2)
    }
}

global rule AddLeftBlock(Block b1, Block b2, CORE c1, CORE c2, SURFACE left, SURFACE right, Shape shape)
when(true,
    NodeSurfaceLeft(left)
) {
    shape.connectSurface(left, right)
}

initializer {
    shape = new Shape()
    
    for(i : seq(0, 3)) {
        block = new Block()

        // Core
        c = new CORE(i)
        nodeCore = block.S.create()
        block.@.bind(c, nodeCore)
        block.S.setCore(@c)
        (CORE FROM block.C).insert(c)

        nodeCore = shape.S.create()
        shape.@.bind(c, nodeCore)
        shape.S.insertCore(@c)
        (CORE FROM shape.C).insert(c)

        // Surface left
        sl = new SURFACE()
        NodeSurfaceLeft = block.S.create()
        block.@.bind(sl, NodeSurfaceLeft)
        block.S.setSurfaceLeft(@sl)
        (SURFACE FROM block.C).insert(sl)

        // Surface right
        sr = new SURFACE()
        NodeSurfaceRight = block.S.create()
        block.@.bind(sr, NodeSurfaceRight)
        block.S.setSurfaceRight(@sr)
        (SURFACE FROM block.C).insert(sr)

  }
}